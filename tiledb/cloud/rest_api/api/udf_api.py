"""
    TileDB Storage Platform API

    TileDB Storage Platform REST API  # noqa: E501

    The version of the OpenAPI document: 2.2.19
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from tiledb.cloud.rest_api.api_client import ApiClient
from tiledb.cloud.rest_api.api_client import Endpoint as _Endpoint
from tiledb.cloud.rest_api.model.array_end_timestamp_data import ArrayEndTimestampData
from tiledb.cloud.rest_api.model.error import Error
from tiledb.cloud.rest_api.model.generic_udf import GenericUDF
from tiledb.cloud.rest_api.model.multi_array_udf import MultiArrayUDF
from tiledb.cloud.rest_api.model.udf_copied import UDFCopied
from tiledb.cloud.rest_api.model.udf_copy import UDFCopy
from tiledb.cloud.rest_api.model.udf_info import UDFInfo
from tiledb.cloud.rest_api.model.udf_info_update import UDFInfoUpdate
from tiledb.cloud.rest_api.model.udf_sharing import UDFSharing
from tiledb.cloud.rest_api.model_utils import check_allowed_values  # noqa: F401
from tiledb.cloud.rest_api.model_utils import check_validations
from tiledb.cloud.rest_api.model_utils import date
from tiledb.cloud.rest_api.model_utils import datetime
from tiledb.cloud.rest_api.model_utils import file_type
from tiledb.cloud.rest_api.model_utils import none_type
from tiledb.cloud.rest_api.model_utils import validate_and_convert_types


class UdfApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.delete_udf_info_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/udf/{namespace}/{name}",
                "operation_id": "delete_udf_info",
                "http_method": "DELETE",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "name",
                ],
                "required": [
                    "namespace",
                    "name",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "name": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "name": "name",
                },
                "location_map": {
                    "namespace": "path",
                    "name": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_udf_info_endpoint = _Endpoint(
            settings={
                "response_type": (UDFInfo,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/udf/{namespace}/{name}",
                "operation_id": "get_udf_info",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "name",
                ],
                "required": [
                    "namespace",
                    "name",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "name": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "name": "name",
                },
                "location_map": {
                    "namespace": "path",
                    "name": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_udf_info_sharing_policies_endpoint = _Endpoint(
            settings={
                "response_type": ([UDFSharing],),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/udf/{namespace}/{name}/share",
                "operation_id": "get_udf_info_sharing_policies",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "name",
                ],
                "required": [
                    "namespace",
                    "name",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "name": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "name": "name",
                },
                "location_map": {
                    "namespace": "path",
                    "name": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.handle_copy_udf_endpoint = _Endpoint(
            settings={
                "response_type": (UDFCopied,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/udf/{namespace}/{name}/copy",
                "operation_id": "handle_copy_udf",
                "http_method": "POST",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "name",
                    "udf_copy",
                    "x_tiledb_cloud_access_credentials_name",
                    "end_timestamp",
                ],
                "required": [
                    "namespace",
                    "name",
                    "udf_copy",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "name": (str,),
                    "udf_copy": (UDFCopy,),
                    "x_tiledb_cloud_access_credentials_name": (str,),
                    "end_timestamp": (int,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "name": "name",
                    "x_tiledb_cloud_access_credentials_name": "X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME",
                    "end_timestamp": "end_timestamp",
                },
                "location_map": {
                    "namespace": "path",
                    "name": "path",
                    "udf_copy": "body",
                    "x_tiledb_cloud_access_credentials_name": "header",
                    "end_timestamp": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": ["application/json"],
            },
            api_client=api_client,
        )
        self.register_udf_info_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/udf/{namespace}/{name}",
                "operation_id": "register_udf_info",
                "http_method": "POST",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "name",
                    "udf",
                ],
                "required": [
                    "namespace",
                    "name",
                    "udf",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "name": (str,),
                    "udf": (UDFInfoUpdate,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "name": "name",
                },
                "location_map": {
                    "namespace": "path",
                    "name": "path",
                    "udf": "body",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": ["application/json"],
            },
            api_client=api_client,
        )
        self.share_udf_info_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/udf/{namespace}/{name}/share",
                "operation_id": "share_udf_info",
                "http_method": "PATCH",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "name",
                    "udf_sharing",
                ],
                "required": [
                    "namespace",
                    "name",
                    "udf_sharing",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "name": (str,),
                    "udf_sharing": (UDFSharing,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "name": "name",
                },
                "location_map": {
                    "namespace": "path",
                    "name": "path",
                    "udf_sharing": "body",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": ["application/json"],
            },
            api_client=api_client,
        )
        self.submit_generic_udf_endpoint = _Endpoint(
            settings={
                "response_type": (file_type,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/udfs/generic/{namespace}",
                "operation_id": "submit_generic_udf",
                "http_method": "POST",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "udf",
                    "accept_encoding",
                ],
                "required": [
                    "namespace",
                    "udf",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "udf": (GenericUDF,),
                    "accept_encoding": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "accept_encoding": "Accept-Encoding",
                },
                "location_map": {
                    "namespace": "path",
                    "udf": "body",
                    "accept_encoding": "header",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/octet-stream"],
                "content_type": ["application/json"],
            },
            api_client=api_client,
        )
        self.submit_multi_array_udf_endpoint = _Endpoint(
            settings={
                "response_type": (file_type,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/udfs/arrays/{namespace}",
                "operation_id": "submit_multi_array_udf",
                "http_method": "POST",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "udf",
                    "accept_encoding",
                ],
                "required": [
                    "namespace",
                    "udf",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "udf": (MultiArrayUDF,),
                    "accept_encoding": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "accept_encoding": "Accept-Encoding",
                },
                "location_map": {
                    "namespace": "path",
                    "udf": "body",
                    "accept_encoding": "header",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/octet-stream"],
                "content_type": ["application/json"],
            },
            api_client=api_client,
        )
        self.submit_udf_endpoint = _Endpoint(
            settings={
                "response_type": (file_type,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/udf/submit",
                "operation_id": "submit_udf",
                "http_method": "POST",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "udf",
                    "x_payer",
                    "accept_encoding",
                    "v2",
                ],
                "required": [
                    "namespace",
                    "array",
                    "udf",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "udf": (MultiArrayUDF,),
                    "x_payer": (str,),
                    "accept_encoding": (str,),
                    "v2": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                    "x_payer": "X-Payer",
                    "accept_encoding": "Accept-Encoding",
                    "v2": "v2",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "udf": "body",
                    "x_payer": "header",
                    "accept_encoding": "header",
                    "v2": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/octet-stream"],
                "content_type": ["application/json"],
            },
            api_client=api_client,
        )
        self.udf_namespace_array_end_timestamps_get_endpoint = _Endpoint(
            settings={
                "response_type": (ArrayEndTimestampData,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/udf/{namespace}/{array}/end_timestamps",
                "operation_id": "udf_namespace_array_end_timestamps_get",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "page",
                    "per_page",
                ],
                "required": [
                    "namespace",
                    "array",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "page": (int,),
                    "per_page": (int,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                    "page": "page",
                    "per_page": "per_page",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "page": "query",
                    "per_page": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.update_udf_info_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/udf/{namespace}/{name}",
                "operation_id": "update_udf_info",
                "http_method": "PATCH",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "name",
                    "udf",
                ],
                "required": [
                    "namespace",
                    "name",
                    "udf",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "name": (str,),
                    "udf": (UDFInfoUpdate,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "name": "name",
                },
                "location_map": {
                    "namespace": "path",
                    "name": "path",
                    "udf": "body",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": ["application/json"],
            },
            api_client=api_client,
        )

    def delete_udf_info(self, namespace, name, **kwargs):
        """delete_udf_info  # noqa: E501

        delete a registered UDF -- this will remove all sharing and can not be undone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_udf_info(namespace, name, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            name (str): name to register UDF under

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["name"] = name
        return self.delete_udf_info_endpoint.call_with_http_info(**kwargs)

    def get_udf_info(self, namespace, name, **kwargs):
        """get_udf_info  # noqa: E501

        get a specific UDF in the given namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_udf_info(namespace, name, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            name (str): name to register UDF under

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            UDFInfo
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["name"] = name
        return self.get_udf_info_endpoint.call_with_http_info(**kwargs)

    def get_udf_info_sharing_policies(self, namespace, name, **kwargs):
        """get_udf_info_sharing_policies  # noqa: E501

        Get all sharing details of the UDF  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_udf_info_sharing_policies(namespace, name, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            name (str): name of UDFInfo

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [UDFSharing]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["name"] = name
        return self.get_udf_info_sharing_policies_endpoint.call_with_http_info(**kwargs)

    def handle_copy_udf(self, namespace, name, udf_copy, **kwargs):
        """handle_copy_udf  # noqa: E501

        Copy a tiledb udf at the specified location  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.handle_copy_udf(namespace, name, udf_copy, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            name (str): name of UDFInfo
            udf_copy (UDFCopy): Input/Output information to copy a UDF

        Keyword Args:
            x_tiledb_cloud_access_credentials_name (str): Optional registered access credentials to use for creation. [optional]
            end_timestamp (int): Milliseconds since Unix epoch. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            UDFCopied
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["name"] = name
        kwargs["udf_copy"] = udf_copy
        return self.handle_copy_udf_endpoint.call_with_http_info(**kwargs)

    def register_udf_info(self, namespace, name, udf, **kwargs):
        """register_udf_info  # noqa: E501

        register a UDF in the given namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.register_udf_info(namespace, name, udf, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            name (str): name to register UDF under
            udf (UDFInfoUpdate): UDF to register

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["name"] = name
        kwargs["udf"] = udf
        return self.register_udf_info_endpoint.call_with_http_info(**kwargs)

    def share_udf_info(self, namespace, name, udf_sharing, **kwargs):
        """share_udf_info  # noqa: E501

        Share a UDF with a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.share_udf_info(namespace, name, udf_sharing, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            name (str): name of UDFInfo
            udf_sharing (UDFSharing): Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it's likely the UDF will not be shared with the namespace at all.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["name"] = name
        kwargs["udf_sharing"] = udf_sharing
        return self.share_udf_info_endpoint.call_with_http_info(**kwargs)

    def submit_generic_udf(self, namespace, udf, **kwargs):
        """submit_generic_udf  # noqa: E501

        submit a generic UDF in the given namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.submit_generic_udf(namespace, udf, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            udf (GenericUDF): UDF to run

        Keyword Args:
            accept_encoding (str): Encoding to use. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            file_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["udf"] = udf
        return self.submit_generic_udf_endpoint.call_with_http_info(**kwargs)

    def submit_multi_array_udf(self, namespace, udf, **kwargs):
        """submit_multi_array_udf  # noqa: E501

        submit a multi-array UDF in the given namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.submit_multi_array_udf(namespace, udf, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            udf (MultiArrayUDF): UDF to run

        Keyword Args:
            accept_encoding (str): Encoding to use. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            file_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["udf"] = udf
        return self.submit_multi_array_udf_endpoint.call_with_http_info(**kwargs)

    def submit_udf(self, namespace, array, udf, **kwargs):
        """submit_udf  # noqa: E501

        send a UDF to run against a specified array/URI registered to a group/project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.submit_udf(namespace, array, udf, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded
            udf (MultiArrayUDF): UDF to run

        Keyword Args:
            x_payer (str): Name of organization or user who should be charged for this request. [optional]
            accept_encoding (str): Encoding to use. [optional]
            v2 (str): flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            file_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        kwargs["udf"] = udf
        return self.submit_udf_endpoint.call_with_http_info(**kwargs)

    def udf_namespace_array_end_timestamps_get(self, namespace, array, **kwargs):
        """udf_namespace_array_end_timestamps_get  # noqa: E501

        retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.udf_namespace_array_end_timestamps_get(namespace, array, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded

        Keyword Args:
            page (int): pagination offset. [optional]
            per_page (int): pagination limit. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArrayEndTimestampData
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        return self.udf_namespace_array_end_timestamps_get_endpoint.call_with_http_info(
            **kwargs
        )

    def update_udf_info(self, namespace, name, udf, **kwargs):
        """update_udf_info  # noqa: E501

        update an existing registered UDF in the given namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_udf_info(namespace, name, udf, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            name (str): name to register UDF under
            udf (UDFInfoUpdate): UDF to update

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["name"] = name
        kwargs["udf"] = udf
        return self.update_udf_info_endpoint.call_with_http_info(**kwargs)
