"""
    TileDB Storage Platform API

    TileDB Storage Platform REST API  # noqa: E501

    The version of the OpenAPI document: 2.2.19
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from tiledb.cloud.rest_api.api_client import ApiClient
from tiledb.cloud.rest_api.api_client import Endpoint as _Endpoint
from tiledb.cloud.rest_api.model.array_activity_log import ArrayActivityLog
from tiledb.cloud.rest_api.model.array_browser_data import ArrayBrowserData
from tiledb.cloud.rest_api.model.array_browser_sidebar import ArrayBrowserSidebar
from tiledb.cloud.rest_api.model.array_end_timestamp_data import ArrayEndTimestampData
from tiledb.cloud.rest_api.model.array_info import ArrayInfo
from tiledb.cloud.rest_api.model.array_info_update import ArrayInfoUpdate
from tiledb.cloud.rest_api.model.array_metadata import ArrayMetadata
from tiledb.cloud.rest_api.model.array_sample import ArraySample
from tiledb.cloud.rest_api.model.array_schema import ArraySchema
from tiledb.cloud.rest_api.model.array_sharing import ArraySharing
from tiledb.cloud.rest_api.model.error import Error
from tiledb.cloud.rest_api.model.last_accessed_array import LastAccessedArray
from tiledb.cloud.rest_api.model.max_buffer_sizes import MaxBufferSizes
from tiledb.cloud.rest_api.model.non_empty_domain import NonEmptyDomain
from tiledb.cloud.rest_api.model.tile_db_config import TileDBConfig
from tiledb.cloud.rest_api.model_utils import check_allowed_values  # noqa: F401
from tiledb.cloud.rest_api.model_utils import check_validations
from tiledb.cloud.rest_api.model_utils import date
from tiledb.cloud.rest_api.model_utils import datetime
from tiledb.cloud.rest_api.model_utils import file_type
from tiledb.cloud.rest_api.model_utils import none_type
from tiledb.cloud.rest_api.model_utils import validate_and_convert_types


class ArrayApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.array_activity_log_endpoint = _Endpoint(
            settings={
                "response_type": ([ArrayActivityLog],),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/activity",
                "operation_id": "array_activity_log",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "start",
                    "end",
                    "event_types",
                    "task_id",
                    "has_task_id",
                ],
                "required": [
                    "namespace",
                    "array",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "start": (int,),
                    "end": (int,),
                    "event_types": (str,),
                    "task_id": (str,),
                    "has_task_id": (bool,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                    "start": "start",
                    "end": "end",
                    "event_types": "event_types",
                    "task_id": "task_id",
                    "has_task_id": "has_task_id",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "start": "query",
                    "end": "query",
                    "event_types": "query",
                    "task_id": "query",
                    "has_task_id": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.arrays_browser_owned_get_endpoint = _Endpoint(
            settings={
                "response_type": (ArrayBrowserData,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/browser/owned",
                "operation_id": "arrays_browser_owned_get",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "page",
                    "per_page",
                    "search",
                    "namespace",
                    "orderby",
                    "permissions",
                    "tag",
                    "exclude_tag",
                    "file_type",
                    "exclude_file_type",
                    "file_property",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "page": (int,),
                    "per_page": (int,),
                    "search": (str,),
                    "namespace": (str,),
                    "orderby": (str,),
                    "permissions": (str,),
                    "tag": ([str],),
                    "exclude_tag": ([str],),
                    "file_type": ([str],),
                    "exclude_file_type": ([str],),
                    "file_property": ([str],),
                },
                "attribute_map": {
                    "page": "page",
                    "per_page": "per_page",
                    "search": "search",
                    "namespace": "namespace",
                    "orderby": "orderby",
                    "permissions": "permissions",
                    "tag": "tag",
                    "exclude_tag": "exclude_tag",
                    "file_type": "file_type",
                    "exclude_file_type": "exclude_file_type",
                    "file_property": "file_property",
                },
                "location_map": {
                    "page": "query",
                    "per_page": "query",
                    "search": "query",
                    "namespace": "query",
                    "orderby": "query",
                    "permissions": "query",
                    "tag": "query",
                    "exclude_tag": "query",
                    "file_type": "query",
                    "exclude_file_type": "query",
                    "file_property": "query",
                },
                "collection_format_map": {
                    "tag": "multi",
                    "exclude_tag": "multi",
                    "file_type": "multi",
                    "exclude_file_type": "multi",
                    "file_property": "multi",
                },
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.arrays_browser_owned_sidebar_get_endpoint = _Endpoint(
            settings={
                "response_type": (ArrayBrowserSidebar,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/browser/owned/sidebar",
                "operation_id": "arrays_browser_owned_sidebar_get",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {},
                "attribute_map": {},
                "location_map": {},
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.arrays_browser_public_get_endpoint = _Endpoint(
            settings={
                "response_type": (ArrayBrowserData,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/browser/public",
                "operation_id": "arrays_browser_public_get",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "page",
                    "per_page",
                    "search",
                    "namespace",
                    "orderby",
                    "permissions",
                    "tag",
                    "exclude_tag",
                    "file_type",
                    "exclude_file_type",
                    "file_property",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "page": (int,),
                    "per_page": (int,),
                    "search": (str,),
                    "namespace": (str,),
                    "orderby": (str,),
                    "permissions": (str,),
                    "tag": ([str],),
                    "exclude_tag": ([str],),
                    "file_type": ([str],),
                    "exclude_file_type": ([str],),
                    "file_property": ([str],),
                },
                "attribute_map": {
                    "page": "page",
                    "per_page": "per_page",
                    "search": "search",
                    "namespace": "namespace",
                    "orderby": "orderby",
                    "permissions": "permissions",
                    "tag": "tag",
                    "exclude_tag": "exclude_tag",
                    "file_type": "file_type",
                    "exclude_file_type": "exclude_file_type",
                    "file_property": "file_property",
                },
                "location_map": {
                    "page": "query",
                    "per_page": "query",
                    "search": "query",
                    "namespace": "query",
                    "orderby": "query",
                    "permissions": "query",
                    "tag": "query",
                    "exclude_tag": "query",
                    "file_type": "query",
                    "exclude_file_type": "query",
                    "file_property": "query",
                },
                "collection_format_map": {
                    "tag": "multi",
                    "exclude_tag": "multi",
                    "file_type": "multi",
                    "exclude_file_type": "multi",
                    "file_property": "multi",
                },
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.arrays_browser_public_sidebar_get_endpoint = _Endpoint(
            settings={
                "response_type": (ArrayBrowserSidebar,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/browser/public/sidebar",
                "operation_id": "arrays_browser_public_sidebar_get",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {},
                "attribute_map": {},
                "location_map": {},
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.arrays_browser_shared_get_endpoint = _Endpoint(
            settings={
                "response_type": (ArrayBrowserData,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/browser/shared",
                "operation_id": "arrays_browser_shared_get",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "page",
                    "per_page",
                    "search",
                    "namespace",
                    "orderby",
                    "permissions",
                    "tag",
                    "exclude_tag",
                    "file_type",
                    "exclude_file_type",
                    "file_property",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "page": (int,),
                    "per_page": (int,),
                    "search": (str,),
                    "namespace": (str,),
                    "orderby": (str,),
                    "permissions": (str,),
                    "tag": ([str],),
                    "exclude_tag": ([str],),
                    "file_type": ([str],),
                    "exclude_file_type": ([str],),
                    "file_property": ([str],),
                },
                "attribute_map": {
                    "page": "page",
                    "per_page": "per_page",
                    "search": "search",
                    "namespace": "namespace",
                    "orderby": "orderby",
                    "permissions": "permissions",
                    "tag": "tag",
                    "exclude_tag": "exclude_tag",
                    "file_type": "file_type",
                    "exclude_file_type": "exclude_file_type",
                    "file_property": "file_property",
                },
                "location_map": {
                    "page": "query",
                    "per_page": "query",
                    "search": "query",
                    "namespace": "query",
                    "orderby": "query",
                    "permissions": "query",
                    "tag": "query",
                    "exclude_tag": "query",
                    "file_type": "query",
                    "exclude_file_type": "query",
                    "file_property": "query",
                },
                "collection_format_map": {
                    "tag": "multi",
                    "exclude_tag": "multi",
                    "file_type": "multi",
                    "exclude_file_type": "multi",
                    "file_property": "multi",
                },
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.arrays_browser_shared_sidebar_get_endpoint = _Endpoint(
            settings={
                "response_type": (ArrayBrowserSidebar,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/browser/shared/sidebar",
                "operation_id": "arrays_browser_shared_sidebar_get",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {},
                "attribute_map": {},
                "location_map": {},
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.arrays_namespace_array_end_timestamps_get_endpoint = _Endpoint(
            settings={
                "response_type": (ArrayEndTimestampData,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/end_timestamps",
                "operation_id": "arrays_namespace_array_end_timestamps_get",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "page",
                    "per_page",
                ],
                "required": [
                    "namespace",
                    "array",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "page": (int,),
                    "per_page": (int,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                    "page": "page",
                    "per_page": "per_page",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "page": "query",
                    "per_page": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.consolidate_array_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/consolidate",
                "operation_id": "consolidate_array",
                "http_method": "POST",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "tiledb_config",
                ],
                "required": [
                    "namespace",
                    "array",
                    "tiledb_config",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "tiledb_config": (TileDBConfig,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "tiledb_config": "body",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": ["application/json"],
            },
            api_client=api_client,
        )
        self.create_array_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}",
                "operation_id": "create_array",
                "http_method": "POST",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "content_type",
                    "array_schema",
                    "x_tiledb_cloud_access_credentials_name",
                ],
                "required": [
                    "namespace",
                    "array",
                    "content_type",
                    "array_schema",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "content_type": (str,),
                    "array_schema": (ArraySchema,),
                    "x_tiledb_cloud_access_credentials_name": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                    "content_type": "Content-Type",
                    "x_tiledb_cloud_access_credentials_name": "X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "content_type": "header",
                    "array_schema": "body",
                    "x_tiledb_cloud_access_credentials_name": "header",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": ["application/json"],
            },
            api_client=api_client,
        )
        self.delete_array_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}",
                "operation_id": "delete_array",
                "http_method": "DELETE",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "content_type",
                ],
                "required": [
                    "namespace",
                    "array",
                    "content_type",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "content_type": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                    "content_type": "Content-Type",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "content_type": "header",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.deregister_array_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/deregister",
                "operation_id": "deregister_array",
                "http_method": "DELETE",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                ],
                "required": [
                    "namespace",
                    "array",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_activity_log_by_id_endpoint = _Endpoint(
            settings={
                "response_type": (ArrayActivityLog,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/activity/{id}",
                "operation_id": "get_activity_log_by_id",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "id",
                ],
                "required": [
                    "namespace",
                    "array",
                    "id",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "id": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                    "id": "id",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "id": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_all_array_metadata_endpoint = _Endpoint(
            settings={
                "response_type": ([ArrayInfo],),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays",
                "operation_id": "get_all_array_metadata",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "public_share",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "public_share": (str,),
                },
                "attribute_map": {
                    "public_share": "public_share",
                },
                "location_map": {
                    "public_share": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_array_endpoint = _Endpoint(
            settings={
                "response_type": (ArraySchema,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}",
                "operation_id": "get_array",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "content_type",
                ],
                "required": [
                    "namespace",
                    "array",
                    "content_type",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "content_type": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                    "content_type": "Content-Type",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "content_type": "header",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json", "application/capnp"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_array_max_buffer_sizes_endpoint = _Endpoint(
            settings={
                "response_type": (MaxBufferSizes,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/max_buffer_sizes",
                "operation_id": "get_array_max_buffer_sizes",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "subarray",
                    "content_type",
                    "x_payer",
                ],
                "required": [
                    "namespace",
                    "array",
                    "subarray",
                    "content_type",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "subarray": (str,),
                    "content_type": (str,),
                    "x_payer": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                    "subarray": "subarray",
                    "content_type": "Content-Type",
                    "x_payer": "X-Payer",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "subarray": "query",
                    "content_type": "header",
                    "x_payer": "header",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_array_meta_data_json_endpoint = _Endpoint(
            settings={
                "response_type": (
                    bool,
                    date,
                    datetime,
                    dict,
                    float,
                    int,
                    list,
                    str,
                    none_type,
                ),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/metadata_json",
                "operation_id": "get_array_meta_data_json",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "length",
                    "end_timestamp",
                ],
                "required": [
                    "namespace",
                    "array",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "length": (int,),
                    "end_timestamp": (int,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                    "length": "length",
                    "end_timestamp": "end_timestamp",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "length": "query",
                    "end_timestamp": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_array_metadata_endpoint = _Endpoint(
            settings={
                "response_type": (ArrayInfo,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/metadata",
                "operation_id": "get_array_metadata",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                ],
                "required": [
                    "namespace",
                    "array",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_array_metadata_capnp_endpoint = _Endpoint(
            settings={
                "response_type": (ArrayMetadata,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/array_metadata",
                "operation_id": "get_array_metadata_capnp",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                ],
                "required": [
                    "namespace",
                    "array",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json", "application/capnp"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_array_non_empty_domain_endpoint = _Endpoint(
            settings={
                "response_type": (NonEmptyDomain,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/non_empty_domain",
                "operation_id": "get_array_non_empty_domain",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "content_type",
                    "x_payer",
                ],
                "required": [
                    "namespace",
                    "array",
                    "content_type",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "content_type": (str,),
                    "x_payer": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                    "content_type": "Content-Type",
                    "x_payer": "X-Payer",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "content_type": "header",
                    "x_payer": "header",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_array_non_empty_domain_json_endpoint = _Endpoint(
            settings={
                "response_type": (
                    bool,
                    date,
                    datetime,
                    dict,
                    float,
                    int,
                    list,
                    str,
                    none_type,
                ),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/non_empty_domain_json",
                "operation_id": "get_array_non_empty_domain_json",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                ],
                "required": [
                    "namespace",
                    "array",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_array_sample_data_endpoint = _Endpoint(
            settings={
                "response_type": (ArraySample,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/sample",
                "operation_id": "get_array_sample_data",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "samples",
                ],
                "required": [
                    "namespace",
                    "array",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "samples": (float,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                    "samples": "samples",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "samples": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_array_sharing_policies_endpoint = _Endpoint(
            settings={
                "response_type": ([ArraySharing],),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/share",
                "operation_id": "get_array_sharing_policies",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                ],
                "required": [
                    "namespace",
                    "array",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_arrays_in_namespace_endpoint = _Endpoint(
            settings={
                "response_type": ([ArrayInfo],),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}",
                "operation_id": "get_arrays_in_namespace",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                ],
                "required": [
                    "namespace",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                },
                "location_map": {
                    "namespace": "path",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_fragment_end_timestamp_endpoint = _Endpoint(
            settings={
                "response_type": (int,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/fragment_end_timestamp",
                "operation_id": "get_fragment_end_timestamp",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "end_timestamp",
                ],
                "required": [
                    "namespace",
                    "array",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "end_timestamp": (int,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                    "end_timestamp": "end_timestamp",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "end_timestamp": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.get_last_accessed_arrays_endpoint = _Endpoint(
            settings={
                "response_type": ([LastAccessedArray],),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/last_accessed",
                "operation_id": "get_last_accessed_arrays",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {},
                "attribute_map": {},
                "location_map": {},
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.register_array_endpoint = _Endpoint(
            settings={
                "response_type": (ArrayInfo,),
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/register",
                "operation_id": "register_array",
                "http_method": "POST",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "array_metadata",
                ],
                "required": [
                    "namespace",
                    "array",
                    "array_metadata",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "array_metadata": (ArrayInfoUpdate,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "array_metadata": "body",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": ["application/json"],
            },
            api_client=api_client,
        )
        self.share_array_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/share",
                "operation_id": "share_array",
                "http_method": "PATCH",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "array_sharing",
                ],
                "required": [
                    "namespace",
                    "array",
                    "array_sharing",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "array_sharing": (ArraySharing,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "array_sharing": "body",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": ["application/json"],
            },
            api_client=api_client,
        )
        self.update_array_metadata_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/metadata",
                "operation_id": "update_array_metadata",
                "http_method": "PATCH",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "array_metadata",
                ],
                "required": [
                    "namespace",
                    "array",
                    "array_metadata",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "array_metadata": (ArrayInfoUpdate,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "array_metadata": "body",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": ["application/json"],
            },
            api_client=api_client,
        )
        self.update_array_metadata_capnp_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/array_metadata",
                "operation_id": "update_array_metadata_capnp",
                "http_method": "POST",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "array_metadata_entries",
                ],
                "required": [
                    "namespace",
                    "array",
                    "array_metadata_entries",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "array_metadata_entries": (ArrayMetadata,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "array_metadata_entries": "body",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json", "application/capnp"],
                "content_type": ["application/json", "application/capnp"],
            },
            api_client=api_client,
        )
        self.vacuum_array_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": ["ApiKeyAuth", "BasicAuth"],
                "endpoint_path": "/arrays/{namespace}/{array}/vacuum",
                "operation_id": "vacuum_array",
                "http_method": "POST",
                "servers": None,
            },
            params_map={
                "all": [
                    "namespace",
                    "array",
                    "tiledb_config",
                ],
                "required": [
                    "namespace",
                    "array",
                    "tiledb_config",
                ],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "namespace": (str,),
                    "array": (str,),
                    "tiledb_config": (TileDBConfig,),
                },
                "attribute_map": {
                    "namespace": "namespace",
                    "array": "array",
                },
                "location_map": {
                    "namespace": "path",
                    "array": "path",
                    "tiledb_config": "body",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": ["application/json"],
                "content_type": ["application/json"],
            },
            api_client=api_client,
        )

    def array_activity_log(self, namespace, array, **kwargs):
        """array_activity_log  # noqa: E501

        get array activity logs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.array_activity_log(namespace, array, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded

        Keyword Args:
            start (int): Start time of window of fetch logs, unix epoch in seconds (default: seven days ago). [optional]
            end (int): End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp). [optional]
            event_types (str): Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated. [optional]
            task_id (str): Array task ID To filter activity to. [optional]
            has_task_id (bool): Excludes activity log results that do not contain an array task UUID. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [ArrayActivityLog]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        return self.array_activity_log_endpoint.call_with_http_info(**kwargs)

    def arrays_browser_owned_get(self, **kwargs):
        """arrays_browser_owned_get  # noqa: E501

        Fetch a list of all arrays that are owned directly by user or user's organizations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.arrays_browser_owned_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            page (int): pagination offset. [optional]
            per_page (int): pagination limit. [optional]
            search (str): search string that will look at name, namespace or description fields. [optional]
            namespace (str): namespace. [optional]
            orderby (str): sort by which field valid values include last_accessed, size, name. [optional]
            permissions (str): permissions valid values include read, read_write, write, admin. [optional]
            tag ([str]): tag to search for, more than one can be included. [optional]
            exclude_tag ([str]): tags to exclude matching array in results, more than one can be included. [optional]
            file_type ([str]): file_type to search for, more than one can be included. [optional]
            exclude_file_type ([str]): file_type to exclude matching array in results, more than one can be included. [optional]
            file_property ([str]): file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArrayBrowserData
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.arrays_browser_owned_get_endpoint.call_with_http_info(**kwargs)

    def arrays_browser_owned_sidebar_get(self, **kwargs):
        """arrays_browser_owned_sidebar_get  # noqa: E501

        Fetch a sidebar for arrays that are owned directly by user or user's organizations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.arrays_browser_owned_sidebar_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArrayBrowserSidebar
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.arrays_browser_owned_sidebar_get_endpoint.call_with_http_info(
            **kwargs
        )

    def arrays_browser_public_get(self, **kwargs):
        """arrays_browser_public_get  # noqa: E501

        Fetch a list of all arrays that have been shared publically  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.arrays_browser_public_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            page (int): pagination offset. [optional]
            per_page (int): pagination limit. [optional]
            search (str): search string that will look at name, namespace or description fields. [optional]
            namespace (str): namespace. [optional]
            orderby (str): sort by which field valid values include last_accessed, size, name. [optional]
            permissions (str): permissions valid values include read, read_write, write, admin. [optional]
            tag ([str]): tag to search for, more than one can be included. [optional]
            exclude_tag ([str]): tags to exclude matching array in results, more than one can be included. [optional]
            file_type ([str]): file_type to search for, more than one can be included. [optional]
            exclude_file_type ([str]): file_type to exclude matching array in results, more than one can be included. [optional]
            file_property ([str]): file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArrayBrowserData
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.arrays_browser_public_get_endpoint.call_with_http_info(**kwargs)

    def arrays_browser_public_sidebar_get(self, **kwargs):
        """arrays_browser_public_sidebar_get  # noqa: E501

        Fetch a sidebar of all arrays that have been shared publically  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.arrays_browser_public_sidebar_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArrayBrowserSidebar
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.arrays_browser_public_sidebar_get_endpoint.call_with_http_info(
            **kwargs
        )

    def arrays_browser_shared_get(self, **kwargs):
        """arrays_browser_shared_get  # noqa: E501

        Fetch a list of all arrays that have been shared with the user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.arrays_browser_shared_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            page (int): pagination offset. [optional]
            per_page (int): pagination limit. [optional]
            search (str): search string that will look at name, namespace or description fields. [optional]
            namespace (str): namespace. [optional]
            orderby (str): sort by which field valid values include last_accessed, size, name. [optional]
            permissions (str): permissions valid values include read, read_write, write, admin. [optional]
            tag ([str]): tag to search for, more than one can be included. [optional]
            exclude_tag ([str]): tags to exclude matching array in results, more than one can be included. [optional]
            file_type ([str]): file_type to search for, more than one can be included. [optional]
            exclude_file_type ([str]): file_type to exclude matching array in results, more than one can be included. [optional]
            file_property ([str]): file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArrayBrowserData
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.arrays_browser_shared_get_endpoint.call_with_http_info(**kwargs)

    def arrays_browser_shared_sidebar_get(self, **kwargs):
        """arrays_browser_shared_sidebar_get  # noqa: E501

        Fetch a list of all arrays that have been shared with the user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.arrays_browser_shared_sidebar_get(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArrayBrowserSidebar
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.arrays_browser_shared_sidebar_get_endpoint.call_with_http_info(
            **kwargs
        )

    def arrays_namespace_array_end_timestamps_get(self, namespace, array, **kwargs):
        """arrays_namespace_array_end_timestamps_get  # noqa: E501

        retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.arrays_namespace_array_end_timestamps_get(namespace, array, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded

        Keyword Args:
            page (int): pagination offset. [optional]
            per_page (int): pagination limit. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArrayEndTimestampData
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        return (
            self.arrays_namespace_array_end_timestamps_get_endpoint.call_with_http_info(
                **kwargs
            )
        )

    def consolidate_array(self, namespace, array, tiledb_config, **kwargs):
        """consolidate_array  # noqa: E501

        consolidate an array at a specified URI  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.consolidate_array(namespace, array, tiledb_config, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded
            tiledb_config (TileDBConfig): tiledb configuration

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        kwargs["tiledb_config"] = tiledb_config
        return self.consolidate_array_endpoint.call_with_http_info(**kwargs)

    def create_array(
        self, namespace, array, array_schema, content_type="application/json", **kwargs
    ):
        """create_array  # noqa: E501

        create a array schema at a specified URI registered to a group/project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_array(namespace, array, array_schema, content_type="application/json", async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded
            array_schema (ArraySchema): ArraySchema being created
            content_type (str): Content Type of input and return mime. defaults to "application/json", must be one of ["application/json"]

        Keyword Args:
            x_tiledb_cloud_access_credentials_name (str): Optional registered access credentials to use for creation. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        kwargs["content_type"] = content_type
        kwargs["array_schema"] = array_schema
        return self.create_array_endpoint.call_with_http_info(**kwargs)

    def delete_array(self, namespace, array, content_type="application/json", **kwargs):
        """delete_array  # noqa: E501

        delete a array  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_array(namespace, array, content_type="application/json", async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded
            content_type (str): Content Type of input and return mime. defaults to "application/json", must be one of ["application/json"]

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        kwargs["content_type"] = content_type
        return self.delete_array_endpoint.call_with_http_info(**kwargs)

    def deregister_array(self, namespace, array, **kwargs):
        """deregister_array  # noqa: E501

        deregister a array  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.deregister_array(namespace, array, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        return self.deregister_array_endpoint.call_with_http_info(**kwargs)

    def get_activity_log_by_id(self, namespace, array, id, **kwargs):
        """get_activity_log_by_id  # noqa: E501

        get activity log by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_activity_log_by_id(namespace, array, id, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded
            id (str): ID of the activity

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArrayActivityLog
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        kwargs["id"] = id
        return self.get_activity_log_by_id_endpoint.call_with_http_info(**kwargs)

    def get_all_array_metadata(self, **kwargs):
        """get_all_array_metadata  # noqa: E501

        get all array metadata user has access to  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_all_array_metadata(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            public_share (str): Public share values can be one of exclude, only. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [ArrayInfo]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.get_all_array_metadata_endpoint.call_with_http_info(**kwargs)

    def get_array(self, namespace, array, content_type="application/json", **kwargs):
        """get_array  # noqa: E501

        get an ArraySchema using a url encoded uri  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_array(namespace, array, content_type="application/json", async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded
            content_type (str): Content Type of input and return mime. defaults to "application/json", must be one of ["application/json"]

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArraySchema
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        kwargs["content_type"] = content_type
        return self.get_array_endpoint.call_with_http_info(**kwargs)

    def get_array_max_buffer_sizes(
        self, namespace, array, subarray, content_type="application/json", **kwargs
    ):
        """get_array_max_buffer_sizes  # noqa: E501

        get the max buffer sizes of an array for a subarray  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_array_max_buffer_sizes(namespace, array, subarray, content_type="application/json", async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded
            subarray (str): CSV string of subarray to get max buffer sizes for
            content_type (str): Content Type of input and return mime. defaults to "application/json", must be one of ["application/json"]

        Keyword Args:
            x_payer (str): Name of organization or user who should be charged for this request. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            MaxBufferSizes
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        kwargs["subarray"] = subarray
        kwargs["content_type"] = content_type
        return self.get_array_max_buffer_sizes_endpoint.call_with_http_info(**kwargs)

    def get_array_meta_data_json(self, namespace, array, **kwargs):
        """get_array_meta_data_json  # noqa: E501

        get metadata from the array in JSON format  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_array_meta_data_json(namespace, array, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded

        Keyword Args:
            length (int): (optional) limit character length of returned values. [optional]
            end_timestamp (int): Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        return self.get_array_meta_data_json_endpoint.call_with_http_info(**kwargs)

    def get_array_metadata(self, namespace, array, **kwargs):
        """get_array_metadata  # noqa: E501

        get metadata on an array  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_array_metadata(namespace, array, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArrayInfo
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        return self.get_array_metadata_endpoint.call_with_http_info(**kwargs)

    def get_array_metadata_capnp(self, namespace, array, **kwargs):
        """get_array_metadata_capnp  # noqa: E501

        get metadata on an array  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_array_metadata_capnp(namespace, array, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArrayMetadata
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        return self.get_array_metadata_capnp_endpoint.call_with_http_info(**kwargs)

    def get_array_non_empty_domain(
        self, namespace, array, content_type="application/json", **kwargs
    ):
        """get_array_non_empty_domain  # noqa: E501

        get the non empty domain of an array  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_array_non_empty_domain(namespace, array, content_type="application/json", async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded
            content_type (str): Content Type of input and return mime. defaults to "application/json", must be one of ["application/json"]

        Keyword Args:
            x_payer (str): Name of organization or user who should be charged for this request. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            NonEmptyDomain
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        kwargs["content_type"] = content_type
        return self.get_array_non_empty_domain_endpoint.call_with_http_info(**kwargs)

    def get_array_non_empty_domain_json(self, namespace, array, **kwargs):
        """get_array_non_empty_domain_json  # noqa: E501

        get non-empty domain from the array in json format  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_array_non_empty_domain_json(namespace, array, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        return self.get_array_non_empty_domain_json_endpoint.call_with_http_info(
            **kwargs
        )

    def get_array_sample_data(self, namespace, array, **kwargs):
        """get_array_sample_data  # noqa: E501

        get an sample set of data from the array  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_array_sample_data(namespace, array, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded

        Keyword Args:
            samples (float): Number of sample results to return. [optional] if omitted the server will use the default value of 5.0
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArraySample
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        return self.get_array_sample_data_endpoint.call_with_http_info(**kwargs)

    def get_array_sharing_policies(self, namespace, array, **kwargs):
        """get_array_sharing_policies  # noqa: E501

        Get all sharing details of the array  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_array_sharing_policies(namespace, array, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [ArraySharing]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        return self.get_array_sharing_policies_endpoint.call_with_http_info(**kwargs)

    def get_arrays_in_namespace(self, namespace, **kwargs):
        """get_arrays_in_namespace  # noqa: E501

        get metadata on all arrays in a namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_arrays_in_namespace(namespace, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [ArrayInfo]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        return self.get_arrays_in_namespace_endpoint.call_with_http_info(**kwargs)

    def get_fragment_end_timestamp(self, namespace, array, **kwargs):
        """get_fragment_end_timestamp  # noqa: E501

        Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_fragment_end_timestamp(namespace, array, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded

        Keyword Args:
            end_timestamp (int): Milliseconds since Unix epoch. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            int
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        return self.get_fragment_end_timestamp_endpoint.call_with_http_info(**kwargs)

    def get_last_accessed_arrays(self, **kwargs):
        """get_last_accessed_arrays  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_last_accessed_arrays(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [LastAccessedArray]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.get_last_accessed_arrays_endpoint.call_with_http_info(**kwargs)

    def register_array(self, namespace, array, array_metadata, **kwargs):
        """register_array  # noqa: E501

        register an array at a specified URI registered to the given namespace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.register_array(namespace, array, array_metadata, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded
            array_metadata (ArrayInfoUpdate): metadata associated with array

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ArrayInfo
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        kwargs["array_metadata"] = array_metadata
        return self.register_array_endpoint.call_with_http_info(**kwargs)

    def share_array(self, namespace, array, array_sharing, **kwargs):
        """share_array  # noqa: E501

        Share an array with a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.share_array(namespace, array, array_sharing, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded
            array_sharing (ArraySharing): Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it's likely the array will not be shared with the namespace at all.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        kwargs["array_sharing"] = array_sharing
        return self.share_array_endpoint.call_with_http_info(**kwargs)

    def update_array_metadata(self, namespace, array, array_metadata, **kwargs):
        """update_array_metadata  # noqa: E501

        update metadata on an array  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_array_metadata(namespace, array, array_metadata, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded
            array_metadata (ArrayInfoUpdate): array metadata to update

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        kwargs["array_metadata"] = array_metadata
        return self.update_array_metadata_endpoint.call_with_http_info(**kwargs)

    def update_array_metadata_capnp(
        self, namespace, array, array_metadata_entries, **kwargs
    ):
        """update_array_metadata_capnp  # noqa: E501

        update metadata on an array  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_array_metadata_capnp(namespace, array, array_metadata_entries, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded
            array_metadata_entries (ArrayMetadata): List of metadata entries

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        kwargs["array_metadata_entries"] = array_metadata_entries
        return self.update_array_metadata_capnp_endpoint.call_with_http_info(**kwargs)

    def vacuum_array(self, namespace, array, tiledb_config, **kwargs):
        """vacuum_array  # noqa: E501

        vacuum an array at a specified URI  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vacuum_array(namespace, array, tiledb_config, async_req=True)
        >>> result = thread.get()

        Args:
            namespace (str): namespace array is in (an organization name or user's username)
            array (str): name/uri of array that is url-encoded
            tiledb_config (TileDBConfig): tiledb configuration

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        kwargs["namespace"] = namespace
        kwargs["array"] = array
        kwargs["tiledb_config"] = tiledb_config
        return self.vacuum_array_endpoint.call_with_http_info(**kwargs)
