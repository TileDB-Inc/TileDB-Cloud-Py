import socket
import sys
import urllib.parse
from typing import Dict, Sequence, Tuple

import urllib3
from urllib3 import connection


def wrap(pm: urllib3.PoolManager) -> urllib3.PoolManager:
    """Wraps a PoolManager to get TileDB Cloud–specific behavior."""
    _set_keepalive(pm)
    return _PoolManagerWrapper(pm)


# Based on information from Stack Overflow:
# https://stackoverflow.com/q/12248132/39808

_KEEPALIVE_SECONDS = 60
"""The delay and interval before sending keepalive packets."""
_DARWIN_KEEPALIVE = 0x10
"""The socket option for keepalive on Mac OS systems."""
_KEEPALIVE_SOCKOPTS: Dict[str, Sequence[Tuple[int, int, int]]] = {
    "linux": (
        (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),
        (socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, _KEEPALIVE_SECONDS),
        (socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, _KEEPALIVE_SECONDS),
    ),
    "darwin": (
        (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),
        (socket.IPPROTO_TCP, _DARWIN_KEEPALIVE, _KEEPALIVE_SECONDS),
    ),
    # TODO: Windows requires an ioctl:
    #     sock.ioctl(socket.SIO_KEEPALIVE_VALS, (1, idle_msec, intvl_msec))
    # Is there a way to accomplish this in urllib3?
}


def _set_keepalive(pm: urllib3.PoolManager) -> None:
    """Sets per-platform keepalive sockopts."""
    sockopts = list(connection.HTTPConnection.default_socket_options)
    try:
        addl_sockopts = _KEEPALIVE_SOCKOPTS[sys.platform]
    except KeyError:
        # We don't what options to set on this platform. ¯\_(ツ)_/¯
        return
    sockopts.extend(addl_sockopts)
    pm.connection_pool_kw["socket_options"] = sockopts


class _PoolManagerWrapper:
    """
    Wrapper around urllib3.PoolManager that implements request() which
    is the only method used by the autogenerated API code

    It can be used to replace tiledb.cloud.rest_api.rest.RESTClientObject.pool_manager
    at runtime in order to cache HTTP redirects and work around
    https://github.com/urllib3/urllib3/issues/2475
    """

    def __init__(self, pool_manager: urllib3.PoolManager):
        self._pool = pool_manager
        # The cache key is the URL without the query string, while
        # the cache value is the FQDN (netloc) of the redirect location
        # For example:
        # {'https://api.tiledb.com/v1/user': 'us-east-1.aws.api.tiledb.com'}
        self._redirect_cache: Dict[str, str] = {}

    def request(
        self,
        method: str,
        url: str,
        **kwargs,
    ):
        kwargs.setdefault("retries", self._pool.connection_pool_kw.get("retries"))

        parsed_url = urllib.parse.urlparse(url)
        cacheable_url = urllib.parse.urljoin(
            f"{parsed_url.scheme}://{parsed_url.netloc}",
            parsed_url.path,
        )

        cached_netloc = self._redirect_cache.get(cacheable_url)
        if cached_netloc:
            url = parsed_url._replace(netloc=cached_netloc).geturl()

        resp = self._pool.request(method, url, **kwargs)

        for retry in reversed(resp.retries.history):
            if retry.redirect_location:
                redirect_netloc = urllib.parse.urlparse(retry.redirect_location).netloc
                self._redirect_cache[cacheable_url] = redirect_netloc

                break

        return resp
